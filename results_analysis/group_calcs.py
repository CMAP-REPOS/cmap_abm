#!/usr/bin/env python
'''
    group_calcs.py
    Author: npeterson
    Revised: 3/15/16
    ---------------------------------------------------------------------------
    A script that compares the change in boardings for transit nodes or lines
    by base boarding group from several test ABM objects to a common base. The
    groups are calculated by taking successive fractions of nodes or lines,
    ordered by boardings (e.g. 50% of all boardings, 50% of remainder, and so
    on) for a specified number of groupings. This may be preferable to
    quantiles because there are so many lines/nodes with 0 (or near-0)
    boardings, and so few with many boardings, that quantile summaries may not
    meaningfully represent the data.

'''
from abm import *

GROUPS = 6
FRACTION = 0.5

# Initialize ABM objects
b = ABM(r'X:\CMAQ_ABM_Models\cmaq_base_20141204', 0.20)

t_ln1 = ABM(r'X:\CMAQ_ABM_Models\cmaq_line_min_20150105', 0.20)
t_ln2 = ABM(r'X:\CMAQ_ABM_Models\cmaq_line_mod_20150112', 0.20)
t_ln3 = ABM(r'X:\CMAQ_ABM_Models\cmaq_line_max_20141208', 0.20)

t_nd1 = ABM(r'X:\CMAQ_ABM_Models\cmaq_node_min_20141222', 0.20)
t_nd2 = ABM(r'X:\CMAQ_ABM_Models\cmaq_node_mod_20150109', 0.20)
t_nd3 = ABM(r'X:\CMAQ_ABM_Models\cmaq_node_max_20141215', 0.20)


def get_boarding_groups(boardings, num_groups, fraction):
    ''' With a dictionary of station/vehicle boardings (generated by
        ABM._get_boardings() as input, return a dictionary with the same
        keys, but where the values are the groups in which the boardings
        fall. These groups will be created by taking successive fractions
        of the remaining boardings, in order, based on a specified
        fraction (e.g. group 1: first half of all boardings; group 2:
        first half of boardings not in group 1; etc.). '''
    # Order boardings
    ordered_boardings = sorted(boardings.itervalues())
    num_boardings = len(ordered_boardings)

    # Calculate interval endpoints for groups
    def find_group_endpoints(num_boardings, num_groups, fraction, group=1, endpoints=None):
        if not endpoints:
            endpoints = {}
        start_pos = max(endpoints.itervalues()) if endpoints else 0
        if group == num_groups:
            end_pos = num_boardings
        else:
            end_pos = int(round(((num_boardings - start_pos) * fraction) + start_pos))
        endpoints[group] = end_pos
        if group < num_groups and end_pos < num_boardings:
            return find_group_endpoints(num_boardings, num_groups, fraction, group+1, endpoints)
        else:
            return endpoints

    endpoints = find_group_endpoints(num_boardings, num_groups, fraction)
    upper_bounds = {k: ordered_boardings[v-1] for k, v in endpoints.iteritems()}

    # Assign nodes/lines to groups
    boarding_groups = {}
    for k, v in boardings.iteritems():
        for group in sorted(upper_bounds.keys()):
            if v <= upper_bounds[group]:
                boarding_groups[k] = group
                break

    return boarding_groups


# Get base boardings and groups
boardings_b = {
    'LINE': b._get_boardings('LINE'),
    'NODE': b._get_boardings('NODE')
}

groups_b = {
    'LINE': get_boarding_groups(boardings_b['LINE'], GROUPS, FRACTION),
    'NODE': get_boarding_groups(boardings_b['NODE'], GROUPS, FRACTION)
}


# Print base boardings
print '\n', b

for node_or_line in sorted(groups_b.keys()):
    print node_or_line, 'BASE MEAN BOARDINGS'
    grp_b = groups_b[node_or_line]
    brd_b = boardings_b[node_or_line]

    # Print mean base boardings by quantile
    for i in xrange(GROUPS):
        n = sum((1 for k in grp_b.iterkeys() if grp_b[k] == i+1))
        mean_base_brd = sum((brd_b[k] for k in grp_b.iterkeys() if grp_b[k] == i+1)) / n if n else 0.
        print 'G{0} ({1}): {2}'.format(i+1, n, mean_base_brd)

    # Print mean base boardings for all nodes/lines
    n = sum((1 for k in grp_b.iterkeys()))
    mean_base_brd = sum((brd_b[k] for k in grp_b.iterkeys())) / n if n else 0.  # Mean of all boardings
    print 'ALL ({0}): {1}\n'.format(n, mean_base_brd)


# Print groups' modal composition
for node_or_line in ['LINE']:
    print node_or_line, 'MODAL COMPOSITION'
    grp_b = groups_b[node_or_line]
    brd_b = boardings_b[node_or_line]

    # Print mean base boardings by quantile
    for i in xrange(GROUPS):
        modes = set((str(tline[0]).upper() for tline in grp_b.iterkeys()))
        n = {}
        for mode in sorted(modes):
            n[mode] = sum((1. for k in grp_b.iterkeys() if grp_b[k] == i+1 and str(k[0]).upper() == mode))
        pct = {mode: round(100.0 * n[mode] / sum(n.itervalues()), 2) for mode in n.keys()}
        print 'G{0}: {1}'.format(i+1, pct)

print '\n'


# Compare test scenario boardings with base, by quantile
def compare_boardings(t, node_or_line, mode=''):
    print '\n', t, mode

    if mode:
        grp_b = groups_b[node_or_line][mode]
        brd_b = boardings_b[node_or_line][mode]
        brd_t = t._get_boardings(node_or_line, split_rail=True)[mode]
    else:
        grp_b = groups_b[node_or_line]
        brd_b = boardings_b[node_or_line]
        brd_t = t._get_boardings(node_or_line, split_rail=False)

    brd_diff = {k: brd_t[k] - brd_b[k] for k in brd_b.iterkeys()}

    # Print mean additional boardings by quantile
    for i in xrange(GROUPS):
        n = sum((1 for k in grp_b.keys() if grp_b[k] == i+1))
        mean_new_brd = sum((brd_diff[k] for k in grp_b.iterkeys() if grp_b[k] == i+1)) / n if n else 0.
        print 'G{0} ({1}): {2}'.format(i+1, n, mean_new_brd)

    # Print mean additional boardings for all nodes/lines
    n = sum((1 for k in grp_b.keys()))
    mean_new_brd = sum((brd_diff[k] for k in grp_b.iterkeys())) / n if n else 0.  # Mean of all boardings
    print 'ALL ({0}): {1}\n'.format(n, mean_new_brd)

    return brd_t

boardings_t_ln1 = compare_boardings(t_ln1, 'LINE')
boardings_t_ln2 = compare_boardings(t_ln2, 'LINE')
boardings_t_ln3 = compare_boardings(t_ln3, 'LINE')

boardings_t_nd1 = compare_boardings(t_nd1, 'NODE')
boardings_t_nd2 = compare_boardings(t_nd2, 'NODE')
boardings_t_nd3 = compare_boardings(t_nd3, 'NODE')
